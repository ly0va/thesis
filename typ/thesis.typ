#let fontsize = 14pt
#show heading: set text(size: fontsize)
#show heading.where(level: 1): it => align(center)[#upper(it) \ ]
#set text(size: fontsize, font: "Noto Serif", lang: "ua")
#show raw: set text(size: fontsize)
#show math.equation: set text(size: 16pt)
#set page(
  paper: "a4",
  margin: (
    top: 20mm,
    bottom: 20mm,
    left: 25mm,
    right: 10mm
  ),
  header: align(right)[#counter(page).display(i => if i != 1 [#i])]
)

#align(center)[
  *КИЇВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ \
  ІМЕНІ ТАРАСА ШЕВЧЕНКА* \
  Факультет комп’ютерних наук та кібернетики \
  Кафедра математичної інформатики \ \ \
  *Кваліфікаційна робота \
  на здобуття ступеня бакалавра* \
  за освітньо-професійною програмою “Інформатика” \
  спеціальності 122 Комп'ютерні науки на тему: \ \
  *РЕАЛІЗАЦІЯ ПРОТОКОЛУ АНОНІМНИХ ПЕРЕКАЗІВ
  ЗА ДОПОМОГОЮ ДОКАЗІВ З НУЛЬОВИМ РОЗГОЛОШЕННЯМ* \ \ \
]

#let signature = [
  \
  #line(length: 100%)
  #align(center, text(size: 0.8em, "(підпис)"))
]

#grid(
  columns: (70%, 30%),
  [
    Виконав студент 4-го курсу \
    Потьомкін Лев Євгенович
  ],
  signature,
  [
    \
    Науковий керівник: \
    Член-кореспондент НАН України, професор \
    Анісімов Анатолій Васильович
  ],
  [\ \ #signature],
)

\ \
#grid(
  columns: (40%, 60%),
  [],
  [
    Засвідчую, що в цій роботі немає запозичень з
    праць інших авторів без відповідних посилань.

    #grid(
      columns: (50%, 50%),
      align(center)[\ Студент],
      signature,
    )
  ]
)

#align(center + bottom)[Київ -- 2023]
#pagebreak()

#let leading = 1.5em
#set par(leading: leading, first-line-indent: 1.27cm)
#show par: set block(spacing: leading)
#show outline: set par(first-line-indent: 0mm)
#show terms: set par(first-line-indent: 0mm)

#heading(outlined: false)[Реферат]

Обсяг роботи:
#locate(loc => counter(page).final(loc).at(0)) сторінок,
#locate(loc => counter(figure.where(kind: image)).final(loc).at(0)) ілюстрацій,
#locate(loc => counter(figure.where(kind: table)).final(loc).at(0)) таблиць,
#locate(loc => counter(ref).final(loc).at(0)) використаних джерел.

Ключові слова: ДОКАЗИ З НУЛЬОВИМ РОЗГОЛОШЕННЯМ, АНОНІМНІ ПЕРЕКАЗИ,
БЛОКЧЕЙН, КРИПТОГРАФІЯ, СМАРТ КОНТРАКТИ, ДЕРЕВО МЕРКЛА.

Об'єктом роботи є протокол анонімних переказів криптовалюти на базі
блокчейну Ethereum.

Метою кваліфікаційної роботи є створення й публікація протоколу
для анонімних переказів з відкритим вихідним кодом для покращення
фінансової приватності в публічних блокчейнах.

Інструментами створення є безкоштовний, вільно поширюваний редактор коду
`Neovim` та мова розмітки тексту `Typst`, мови програмування `Noir`,
`TypeScript`, `Solidity`. Використано фреймворк `Hardhat` та
бібліотеку `ethers.js`.

Результат роботи: розроблено та опубліковано реалізацію протоколу
анонімних переказів під ліцензією MIT.

#pagebreak()

#outline()
#pagebreak()

= Вступ

У сучасному цифровому світі анонімність та конфіденційність стають
все більш важливими, особливо в контексті фінансових операцій.
Станом на 2023 рік існують різні криптовалютні платформи та протоколи,
які надають анонімність та захист конфіденційності при проведенні транзакцій.
Однією з ключових технологій, що забезпечує таку анонімність, є докази з
нульовим розголошенням.

Актуальність даної роботи полягає в розробці протоколу анонімних переказів,
заснованого на доказах з нульовим розголошенням, що забезпечить високий рівень
конфіденційності та безпеки для користувачів. Робота виконана на новій
мові програмування схем з нульовим розголошенням `Noir`, що сприятиме розвитку
мови та доповнить її екосистему проектів, а також допоможе покращити її
надійність шляхом безпосереднього тестування.

Основна мета роботи полягає в аналізі наявних протоколів анонімних переказів
та створенні нового або модифікації існуючого протоколу на основі доказів з
нульовим розголошенням.

Об'єктом дослідження є протоколи анонімних переказів та докази з нульовим розголошенням.
У процесі дослідження будуть використані теоретичні та практичні методи, включаючи
аналіз наукової літератури, математичні моделі, симуляції та реалізацію прототипів.

Можливі сфери застосування результатів роботи включають криптовалютні платформи,
банківські установи, фінтех-компанії та інші організації, які займаються
електронними платежами та фінансовими операціями.

Дана робота базується на реалізації Tornado Cash @tornado – відомого
протоколу для анонімних транзакцій на блокчейні Ethereum. Основні принципи
та ідеї Tornado Cash адаптовані та розширені для даної роботи, зокрема для
використання мови програмування `Noir`.

#pagebreak()

= Скорочення та умовні позначення

/ ZKP: Zero-Knowledge Proof, доказ з нульовим розголошенням;
/ ZKC: Zero-Knowledge Circuits, схеми з нульовим розголошенням;
/ SNARK: Succinct Non-Interactive ARgument of Knowledge;
/ STARK: Scalable Transparent ARgument of Knowledge;
/ PLONK: Permutations over Lagrange-bases for Oecumenical Non-interactive arguments of Knowledge;
/ EVM: Ethereum Virtual Machine, середовище виконання смарт-контрактів
  в блокчейні Ethereum;
/ ERC20: широко використовуваний стандарт токенів в блокчейні Ethereum;
/ DLP: Discrete Logarithm Problem, задача дискретного логарифму;
/ UTXO: Unspent Transaction Output, невитрачений залишок транзакції --
  відокремлена сума криптовалюти з конктретним власником;
/ MPC: Multiparty Computation, протокол багатосторонніх обчислень;
/ MiMC: Minimal Multiplicative Complexity, сімейство хешів з мінімальною
  мультиплікативною складністю;
/ DeFi: Decentralized Finance, децентралізовані фінанси;

#pagebreak()

#set heading(numbering: (..nums) => {
  if nums.pos().len() == 1 {
    "Розділ " + str(nums.pos().at(0)) + "."
  } else {
    numbering("1.", ..nums)
  }
})

= Огляд доказів з нульовим розголошенням
== Означення та властивості
\

Доказ нульового розголошення можна розглядати як взаємодiю мiж
двома комп’ютерними програмами. Oдну з них називають Прувер, а другу
Верифiкатор. Прувер переконує Верифiкатора, що певне математичне
твердження є iстинним. Будь-який доказ нульового розголошення має
задовольняти три властивостi:

+ *Повнота* (Completeness): якщо Прувер чесний (твердження істинне), то врештi-решт вiн переконає Верифiкатора.
+ *Обґрунтованiсть* (Soundness): Прувер може переконати Верифiкатора лише в тому випадку, якщо твердження iстинне.
+ *Нульовий рiвень знань* (Zero knowledge): Верифікатор не дiзнається жодної iнформацiї, окрім факту істинності твердження.

\
== Приклад: схема Шнорра
\

Схема Шнорра @schnorr є одним із найпростіших та найбільш широко використовуваних
протоколів ZKP. Вона дозволяє стороні довести, що вона знає секретнне число,
не розкриваючи його або будь-яку інформацію стосовно нього. Схема використовується,
зокрема, в HTTPS та SSH.

\ \

Протокол наступний:

+ *Підготовка*: Перед початком протоколу сторона, яка доводить знання ключа (прувер), та сторона, якій доводиться (верифікатор), домовляються про певне велике просте число $p$ і примітивний корінь $g$ по модулю $p$. Прувер має секрет $x$, який він не хоче розкривати. Верифікатор знає $y = g^x mod p$.
+ *Комітмент*: Прувер обирає випадкове число $r$ і відправляє $t = g^r mod p$  верифікатору.
+ *Виклик*: Верифікатор відправляє пруверу випадкове число $c$.
+ *Відповідь*: Прувер обчислює $s = r + c x mod p-1$ і відправляє s верифікатору.
+ *Перевірка*: Верифікатор перевіряє, що $g^s mod p$ дорівнює $t y^c mod p$. Якщо рівність виконується, то верифікатор приймає доказ. В іншому випадку доказ відхиляється.

\

У цьому протоколі прувер ніколи не розкриває свій секрет $x$, але все одно може довести,
що він його знає. Одночасно верифікатор може бути впевнений, що прувер знає секрет, не отримуючи
жодної додаткової інформації.

Цей протокол використовує криптографічне припущення про нерозв'язність DLP.

\ \
== Перетворення Фіата-Шаміра
\

Перетворення Фіата-Шаміра @fiat-shamir -- це важлива техніка в криптографії, яка дозволяє
перетворити інтерактивний протокол ZKP на неінтерактивний. Це важливо, тому що
інтерактивність може бути проблематичною для багатьох реальних застосувань, особливо в
онлайн-системах, де велика кількість взаємодій може бути обтяжливою.

У стандартному інтерактивному ZKP, прувер та верифікатор обмінюються декількома
повідомленнями. У випадку протоколу Шнорра, наприклад, прувер починає з надсилання
комітменту, потім верифікатор відправляє випадкове число як виклик, і прувер відповідає
на цей виклик.

Перетворення Фіата-Шаміра дозволяє усунути необхідність в інтерактивності шляхом заміни
виклику верифікатора на криптографічно безпечний хеш від комітменту прувера. Таким
чином, прувер може створити доказ без взаємодії з верифікатором: він створює свій
комітмент, обчислює хеш від цього комітменту, використовує цей хеш як виклик і
відповідає на цей виклик. Згодом верифікатор може перевірити доказ, перевіривши,
що хеш від комітменту прувера справді відповідає виклику і що відповідь правильно
відповідає на виклик.

Це перетворення робить можливим застосування ZKP в неінтерактивних контекстах, таких як
криптовалюти та блокчейн. Проте воно залежить від існування криптографічно безпечних
хеш-функцій, які вважаються стійкими до злому.

\
== zk-SNARKи та довірене налаштування
\

Сімейство пруф-систем zk-SNARK є одним з найпопулярніших на сьогодняшній день,
оскільки дозволяє генерувати короткі докази, які можна швидко верифікувати - незалежно від
розміру обчислень, що доводяться. Проте, вони мають великий спільний недолік.

Довірене налаштування (_trusted setup_) в zk-SNARK є важливою частиною процесу, оскільки
воно генерує початкові параметри, які використовуватимуться під час створення та перевірки
доказів. Налаштування має бути виконано безпечним і надійним способом, оскільки від цього
залежить безпека системи.

Одним із поширених способів проведення довіреного налаштування є протокол багатосторонніх
обчислень (MPC):

+ Кожен учасник самостійно генерує частину параметрів налаштування та зберігає свою частину в таємниці.
+ Кожен учасник використовує свою секретну частину, щоб створити публічну частину параметрів налаштування.
+ Публічні частини від усіх учасників об’єднуються для створення остаточних параметрів для системи zk-SNARK.
+ Приватні частини учасників знищуються.

\

Властивість безпеки цієї установки полягає в тому, що доки принаймні один учасник успішно
знищить свою секретну частину, остаточні параметри не можуть бути використані для
створення хибних доказів.

Одним із прикладів такого підходу на практиці була "церемонія" ZСash, яка являла собою
протокол багатосторонніх обчислень за участю шести учасників. Протокол був розроблений
таким чином, що навіть якби п’ятеро учасників змовилися, щоб зберегти свої секрети та
створити фальшиві докази, зусилля були б марними, доки принаймні один учасник правильно
знищив свій секрет. Церемонія була проведена з високим рівнем свідомості безпеки,
включаючи заходи для запобігання side-channel attacks, які могли стати причиною витоку
секретів.

Хоча цей процес суттєво зменшує ризик, пов’язаний із довіреним налаштуванням, він не
усуває його повністю. Таким чином, системи, які не вимагають надійних установок, як-от
zk-STARK і Bulletproofs, можуть бути більш привабливими в певних контекстах.

\
== Порівняння SNARK, STARK та Bulletproof
\

Тут описані приклади сучасних пруф-систем з їх перевагами та недоліками.

*zk-SNARK*. Частина *S* (_succinct_, стислий) означає, що докази невеликі та їх швидко 
верифікувати, що є ключовою перевагою. Однак вони вимагають окремий _trusted setup_ для
кожної схеми ZKC, що є суттєвим недоліком. Підвид SNARKів під назвою PLONK потребує 
один _trusted setup_ для всіх схем не більше певного розміру (_universal trusted setup_),
що однозначно є покращенням, хоч і не повним вирішенням проблеми.
 
*zk-STARK*. Вони схожі на zk-SNARK, але не вимагають довіреного налаштування, що допомагає
уникнути вищезгаданого ризику безпеки. Вони також стійкі до квантових алгоритмів, адже 
їх безпека залежить тільки від обраної хеш-функції. Однак докази, згенеровані zk-STARK,
більші, ніж ті, що згенеровані zk-SNARK, що може бути недоліком.

*Bulletproof*. Це ще один тип ZKP, який не вимагає довіреного налаштування. Вони в
основному використовуються для покращення конфіденційності в мережі Bitcoin. Розмір
Bulletproof'a логарифмічно зростає як із розміром твердження, яке потрібно підтвердити,
так і з параметром безпеки, що робить їх більш здатними до масштабування. 
Однак вони не такі стислі, як zk-SNARK або zk-STARK, тобто потребують більше
обчислювальних ресурсів для верифікації.

#[
  #set par(leading: 0.5em)
  #figure(
    outlined: false,
    caption: "Порівняльна характеристика пруф-систем",
    table(
      columns: (auto, auto, auto, auto),
      align: center + horizon,
      inset: 10pt,
      [], [*SNARK*], [*STARK*], [*Bulletproof*],
      [Алгоритмічна складність: Прувер], [$O(n log(n))$], [$O(n "poly-log"(n))$], [$O(n log(n))$],
      [Алгоритмічна складність: Верифікатор], [$O(1)$], [$O("poly-log"(n))$], [$O(n)$],
      [Розмір доказу], [$O(1)$], [$O("poly-log"(n))$], [$O(log(n))$],
      [Потрібен trusted setup], [так], [ні], [ні],
      [Стійкість до квантових алгоритмів], [ні], [так], [ні],
      [Криптографічні припущення], [DLP + secure bilinear pairing], [хеші, стійкі до колізій], [DLP],
    )
  )
]

#pagebreak()

= Огляд існуючих протоколів анонімних переказів
== Zcash
\

Zcash (ZEC) це відкрита децентралізована криптовалюта, яка була запущена в 2016 році. Вона була створена з метою надання більш приватної альтернативи іншим криптовалютам, зокрема Bitcoin. В основу Zcash покладено технологію zk-SNARKs, описану в попередньому розділі.

Zcash дозволяє користувачам вибирати, чи робити свої транзакції приватними (_shielded
transactions_), адже вони дорожчі за публічні транзакції та вимагають від користувача
генерації доказу ZKP.

У Zcash, технологія zk-SNARK дозволяє створити транзакцію з доказом, що відправник має достатньо
коштів для проведення транзакції, але без розкриття суми транзакції, відправника та отримувача.
Це гарантує приватність транзакції.

Отже, як це працює на практиці? Нижче наведено кроки, які відбуваються при використанні
конфіденційного переказу в Zcash:

+ *Створення комітменту*: Відправник генерує секретний ключ та публічний ключ. Відправник тоді бере вхідні UTXO, суму, яку вони хочуть відправити, та адресу отримувача, та створює "комітмент". Комітмент є просто хешем всіх цих деталей, який потім записується в блокчейн.
+ *Створення доказу*: Відправник тоді генерує ZKP, що вони знають секретний ключ, який відповідає публічному ключу в комітменті, і що вхідні UTXO містять достатньо коштів для виконання транзакції.
+ *Верифікація*: Коли відправник передає доказ в мережу, вузли в мережі можуть перевірити доказ без відкриття комітменту. Якщо доказ є вірним, транзакція додається в блокчейн, але самі деталі транзакції залишаються прихованими. Завдяки технології zk-SNARKs, Zcash забезпечує приватність транзакцій, не жертвуючи безпекою або цілісністю своєї мережі.

\
== Monero
\

Monero (XMR) - це приватна, децентралізована і безпечна криптовалюта, яка була впроваджена в квітні 2014 року. Вона стала популярною, завдяки наголосу на анонімності та приватності. Це забезпечено через застосування декількох криптографічних технологій:

+ *Кільцеві Підписи* (_Ring Signatures_): використовуються для забезпечення анонімності відправника. Вони дозволяють відправнику підписати транзакцію згрупою можливих підписувачів, тим самим забезпечуючи анонімність, оскільки неможливо визначити, хто з групи дійсно підписав транзакцію.
+ *Сховані адреси* (_Stealth Addresses)_: Monero використовує сховані адреси для забезпечення анонімності отримувача. Коли транзакція виконується, генерується унікальна одноразова адреса, яка асоціюється з кожною транзакцією на стороні отримувача. Це гарантує, що зовнішній спостерігач не може прослідкувати дві транзакції до того ж отримувача.
+ *Кільцеві конфіденційні транзакції* (_RingCT_): використовуються для приховування суми транзакції. Це розширення технології кільцевих підписів, що використовує комітменти Педерсена, які є гомоморфними за додаванням (сума двох комітментів дорівнює комітменту суми). Вони дозволяють довести, що сума входів транзакції дорівнює сумі виходів, без необхідності відкривати фактичні суми.
+ *Криптовалютна мережа Kovri*: Monero планує впровадження мережі Kovri, що дозволить забезпечити анонімність на рівні IP-адреси, використовуючи технологію оніон-маршрутизації. Ця технологія вже давно використовуються, наприклад, в браузері Tor.

\
== MimbleWimble
\

Mimblewimble - це криптовалютний протокол, представлений у 2016 році. Він відрізняється тим, що надає високий рівень приватності і значно більшу ефективність за масштабування в порівнянні з багатьма традиційними криптовалютами.

MimbleWimble використовує декілька криптографічних технологій для забезпечення анонімності 
переказів.

*1. Приховування транзакцій*

У MimbleWimble приховування транзакцій здійснюється за допомогою комітментів Педерсена
(Pedersen Commitments), так само як і в Monero. Kомітмент Педерсена - це гомоморфний за
додаванням криптографічний примітив, який дозволяє зберігати значення таким чином, що воно
приховане, але все ще може бути використане в математичних обчисленнях. Тобто ви можете додавати
зашифровані числа, і отримати той самий (зашифрований) результат, якщо б ви виконували ці
обчислення на незашифрованих числах.

Коли користувач виконує транзакцію, він створює комітмент для кожного залишку (UTXO)
транзакції. Ці комітменти потім використовуються для перевірки того, що загальна сума входів
транзакції дорівнює загальній сумі залишків. Це гарантує, що транзакція є дійсною, без
необхідності відкривати реальні суми переказів.

*2. Об'єднання транзакцій*

MimbleWimble також використовує технологію, відому як CoinJoin, для об'єднання транзакцій.
CoinJoin - це процес, в якому кілька користувачів об'єднують свої транзакції в одну, щоб змішати
інформацію про відправників і отримувачів.

Коли транзакції об'єднуються за допомогою CoinJoin, всі входи та виходи об'єднаних транзакцій
перемішуються разом. Це означає, що неможливо визначити, який вхід відповідає якому виходу, що
допомагає забезпечити анонімність.

Важливо зазначити, що об'єднання транзакцій в MimbleWimble відбувається на рівні протоколу, що
означає, що всі транзакції автоматично об'єднуються, на відміну від деяких інших технологій
CoinJoin, які вимагають активної участі користувачів.

Основою цих механізмів є криптографія на еліптичних кривих, на яких будуються ключові криптографічні примітиви, що використовується в MimbleWimble.

#pagebreak()

= Реалізація

== Опис протоколу
\

За основу протоколу була взята архітектура Tornado Cash.

\
== Хеш MiMC
== Інкрементальне дерево Меркла
== PLONK
== Множина анонімності
== Nullifier
== Iнтеграція з протоколом Aave 



== Flash Loans
\

_Flash Loan_ (миттєва позика) є інноваційною функцією, що була вперше запроваджена протоколом Aave в DeFi просторі. Це тип позики, що дозволяє користувачам позичити будь-яку доступну кількість активів без застави, проте позика повинна бути повернена в рамках однієї транзакції Ethereum.

Це працює наступним чином:

+ Користувач бере Flash Loan.
+ Користувач використовує ці кошти для виконання певних операцій, як-то арбітраж переконфігурація портфоліо, само-погашення позики тощо.
+ Користувач повертає позику з невеликою платою за користування в межах тієї ж транзакції.

\

Якщо позика не повертається, або повертається не повністю, транзакція відкидається і
стан блокчейна повертається до стану перед транзакцією (_revert_), адже будь-яка 
транзакція в Ethereum є атомарною (тобто, вона або виконується повністю, або не 
виконується взагалі).

Цей механізм дозволяє користувачам використовувати значні капіталовкладення для короткострокових
операцій без необхідності великих інвестицій, а також знижує ризики пов'язані з ціною активів.

Ми також можемо реалізувати цю функцію на контракті протоколу 

#pagebreak()

#set heading(numbering: none)

= Висновки
#pagebreak()

= Перелік джерел посилання
#bibliography(title: none, "sources.yml")
